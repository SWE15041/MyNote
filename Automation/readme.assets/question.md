[toc]

# Question



1. 【UAT环境】上周周一、周二，配合recipe重新配置uat测试数据的 +  uat重新测试1.35.0版本，花费两天时间。

2. 【QA环境】测试项目中调用公司mobile api没有版本概念，调用已经被标识为“弃用”的API，导致测试失败，排查问题困难。（测试项目遗留问题，待改进）

3. 【QA环境】测试项目在测试期间，truck session被offline、off duty，导致餐馆不可用，需要重新测试。（受”am2.0“时开时关影响）

4. 【QA环境】对于测试失败的case，人工介入重新测试，需要时刻关注truck session状态、inventory库存，还有需要去cs后台手动cancel订单，很麻烦。（具体看以下excel）

5. 【QA环境】测试期间，发现在前端代码设置的testId被删掉，就需要重新埋点、打包app代码（*.apk,  *.app），非常花时间。（改进方法，每天下班做QA回归）

6. 【QA环境】网络连接超时导致case需要重新测试，有时候UI加载不出来，需要重新测试。




【工作安排】


- 测试数据清理自动化，每次测试完成之后，需要进行订单cancel、truck session设置为off duty
- 将appcenter上的测试进度发送到slack上，用来实时提醒测试人员进行下一步测试。
- 了解测试项目和appcenter 的交互过程。
- 了解allure报告在线访问功能的实现。
- 修改在appcenter进行测试时，生成测试报告的流程，将以email形式整合报告的流程改成 支持在线预览报告的方式。
- 排查为什么appcenter会漏掉部分case的测试？



- 重构打包服务器。（打包，测试、回归测试，测试报告在线访问，历史报告在线访问）

- 实操Appium实现测试。

- 测试数据准备项目，引入其他组的项目依赖来调用API 。








1. UAT新版本本地测试和UAT旧版本本地测试不能并行进行测试。
2. 测试流程（测试数据准备---》测试---》测试数据清理）需要人工多次参与操作。
3. appcenter 测试过程存在 case漏掉测试的情况
4. 中午12点truck session offduty ，导致测试中断，不支持断点续测。
5. 操作需要重测的case过程太过于麻烦。

单台设备进行测试  要支持中断后可继续测试剩余的case
 多台设备进行测试 
1 账号要独立开 不互相干扰 
2 测试报告按照 版本/设备/测试结果 分级管理
3 测试case缺失时 或者其他条件导致 case需要重新测试的时候  重测流程要方便 可视化选择可能更棒。

# 工具问题

从三个环境出发描述问题

【QA】

问题1：不能实时感知APP代码的变化，可能是业务变化，也可能是前端代码调整等，testId被移除。

解决：第一天测试，第二天分析，修改。

【UAT】

问题1:  UAT新版本本地测试和UAT旧版本回归测试不能并行测试，主要是因为使用同一个测试账号的导致的。

解决:  测试的时候账号可以选择，或者准备一批账号，互斥使用。

【appcenter】

问题1: 测试完成后，如果case漏掉，很难发现。

解决: 

问题2: 测试完成后，对需要 **特别提取** 出来放到**指定设备**进行测试的case（漏掉的或测试失败等原因导致的），操作流程复杂，人工参与多，等待时长不可控。（测试设备：测试case= n:n）

解决：

问题3: 测试报告整理过程麻烦（邮箱形式）

解决：**已解决**，将测试结果通过s f tp协议发送到ma c mini服务器，支持浏览器实时在线访问测试结果。

【all】

问题1: 基本测试流程需要人工多次参与操作

解决：应该把这几个步骤（测试数据准备--> 测试--> 测试数据清理）集成起来

问题2:  多种原因（中午12点truck session offduty ，网络问题）可能导致测试中断，项目不支持中断后继续测试还没有测的case，需要重新再测，费时费力。

解决:  ？



从项目出发描述问题

【appium-junit 项目】

问题1: use case之间存在干扰，如UserAddItems 多次被其他case调用，如果在执行其他case的UserAddItems步骤时，总失败次数>2次后，有UserAddItems测试步骤的case不再被执行

解决：？

问题2: appium-junit 在多个环境（qa、uat、appcenter）之间配置区分不明确，代码阅读难，维护难

解决：？

【bo-api-util】

问题1:调用第三方API时，请求参数和返回参数 类型没有对象化，而是以json的格式读取和写入，增加阅读的复杂性和代码维护的难度。

问题2: 不能实时感知第三方API的变化 

问题3: 测试基础数据入侵到代码中，代码可读性差





